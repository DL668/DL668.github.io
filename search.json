[{"title":"小迪23年-32~40——java简单回顾（1）","path":"/2025/08/08/小迪23年-32~40——java简单回顾（1）/","content":"b站小迪23年网安基础课程，28节——31节，java简单回顾（1） 原生类 课堂完结后欲复习巩固也方便后续-重游-故写此篇从实现功能过渡到涉及的相关知识点 Servlet Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。简单来说就是帮你接收和发送浏览器信息的，需自定路由的“中间层” 知识点 1、 有两种设置路由的方式。1.1、最原生的是在 java 同级文件夹 webapp 的里的文件 web.xml 里设置，比如： servlet servlet-namesun/servlet-name servlet-classcom.example.demo1.sun_servlet/servlet-class/servletservlet-mapping servlet-namesun/servlet-name url-pattern/sun1/url-pattern/servlet-mappingservlet-mapping servlet-namesun/servlet-name url-pattern/sun2/url-pattern/servlet-mapping 1.2、还有就是普遍使用的Servlet 3.0引入的一个特性 @Webservlert 注解 @WebServlet注解是Servlet 3.0引入的一个特性，它允许开发者在Servlet类上使用注解来声明Servlet的一些属性，从而避免在web.xml文件中进行配置。 只需了解前两个属性就好：name，value。例：@Webservlet(name=nm,value=/path) ，可简写作@Webservlet(/path) name 的值相当于 web.xml 里的 servlet-name 属性，不写默认为类的全限定名 2、 全限定类名 全限定类名的主要作用是提供一个唯一的类标识，避免不同包中具有相同类名的类之间的冲突。 比如 servlert 必须引用的 HttpServlet 的全限定类名是 ：javax.servlet.http.HttpServlet 3、 除了支持 get、post 方式发送请求的重写方法 doGet 和doPost，还有只在最开始执行一次的 init()，只在销毁的时候执行一次的 destroy Code具体的知识点不多，以自带的 HelloServlet 类为例小小改一下当复习就好了 package com.example.demo1;import java.io.*;import javax.servlet.ServletException;import javax.servlet.http.*;import javax.servlet.annotation.*;@WebServlet(name = helloServlet, value = /hello-servlet)public class HelloServlet extends HttpServlet private String message; @Override public void init() throws ServletException //最先被执行且一次 message = Hello World!; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException response.setContentType(text/html); // Hello PrintWriter out = response.getWriter();// out.println(htmlbody);// out.println(h1 + message + /h1);// out.println(/body/html); // 或者换种支持链式写法 out.append(htmlbody) .append(h1 + message + /h1) .append(/body/html); @Override public void destroy() System.out.println(我销毁了，你看着办); JDBC JDBC（Java Database Connectivity）是Java语言中用于操作关系型数据库的一套API。它提供了一组标准接口，使得Java程序可以与不同的数据库进行交互。JDBC的核心思想是面向接口编程，通过定义一组标准接口，各个数据库厂商实现这些接口，从而提供数据库驱动。 简单流程：导入驱动 jar 包 - 通过反射加载驱动 - 连接数据库 - 请求并接收处理返回的数据库数据 知识点 1、 由于java的预编译语言特性，所以原生开发就有有效的法子预防sql注入（预编译），后面 Code 里细嗦 2、 加载数据库驱动的目的是将 JDBC 驱动加载到 JVM（java虚拟机）里，为后续 连接数据库时调用 JDBC 接口做准备。 //加载数据库驱动try Class.forName(com.mysql.cj.jdbc.Driver); catch (ClassNotFoundException e) throw new RuntimeException(e); 3、 预编译防 sql 原理 预编译（Prepared Statements）是一种在执行SQL查询之前，先将SQL语句的结构固定下来，并将用户输入的参数作为独立的变量处理的方法。具体来说，预编译的SQL语句会先提交给数据库进行编译，生成一个执行计划，然后在执行时再将参数传递给这个执行计划。 所以重点是结构确定了，说简单点就是已经把命令执行完一大半了，就差个参数然后把结果给你了。所以参数是单独处理的！而非拼接然后第二次执行 sql 语句，注入自然是无效的。 Code这里以是否预编译语句连接数据库为例，为了方便测试写在main函数里。如果需要传参也是一样的写在doget里就好了 public static void main(String[]args) throws ClassNotFoundException, SQLException //加载数据库驱动 Class.forName(com.mysql.cj.jdbc.Driver); //获取数据库连接 String url = jdbc:mysql://localhost:3307/class_1; String username = root; String password = password; Connection connection = DriverManager.getConnection(url, username, password); /** * 预编译安全写法 */// String sql = SELECT * FROM news where id=?;// try(PreparedStatement preparedStatement = connection.prepareStatement(sql))// // 设置参数，防止SQL注入攻击// preparedStatement.setString(1,s);// ResultSet resultSet = preparedStatement.executeQuery();// while (resultSet.next()) // int id = resultSet.getInt(id);// String name = resultSet.getString(title);// String author=resultSet.getString(author);// String content=resultSet.getString(content);// String img=resultSet.getString(img);// System.out.println(-----------------------);// System.out.println(id);// System.out.println(name);// System.out.println(author);// System.out.println(content);// System.out.println(img);// // //关闭数据库连接// resultSet.close();// /** * 不安全写法 * */ //sql语句 String sql = SELECT * FROM news where id=1; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); //遍历处理数据库集 while (resultSet.next()) int id = resultSet.getInt(id); String name = resultSet.getString(title); String author=resultSet.getString(author); String content=resultSet.getString(content); String img=resultSet.getString(img); System.out.println(-----------------------); System.out.println(id); System.out.println(name); System.out.println(author); System.out.println(content); System.out.println(img); //关闭数据库连接 resultSet.close(); statement.close(); connection.close(); 编译与非编译写法运行结果分别如下所示：编译：不编译： 安全问题1、 课上讲的就一个是否预编译预防 sql 注入 Filter 过滤器，顾名思义就是过滤作用，在一个请求发送到服务器时，得先经过过滤器（如果有），然后才能到达处理函数。这让过滤器可以完成很多操作，比如身份识别，登录控制，权限管理，过滤敏感词汇等。具体操作就是把包抓到，进行修改然后放行，或者请求拦截返回。 知识点 1、 实现过滤器需要写上注释 @WebFilter(/path) 并实现 Filter 接口在 doFilter 方法里面进行过滤等操作。 2、 以身份验证为例，可以拿 cookie 里面的值来判断是否是管理员（虽然并不安全）。当然请求包里的所有数据都是能拿到的，可以支持很细化的过滤操作。 3、 可以对所有路径进行过滤： @WebFilter(/*)，那也意味着过滤可以又多层，只要把请求下放。 Code这里两层过滤分别进行-身份识别-和-xss过滤-为例 第一层过滤：过滤非管理员用户（adminFilter） @WebFilter(/*)//所有路径都检测一下是否是管理员public class adminFilter implements Filter @Override public void init(FilterConfig filterConfig) throws ServletException System.out.println(---Filter:path:/*：启动成功——init); @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException System.out.println(---Filter:path:/*：开始过滤——doFilter); //两步，判断与放行 HttpServletRequest req=(HttpServletRequest)servletRequest; HttpServletResponse rsp=(HttpServletResponse) servletResponse; //获取Cookies Cookie[] cookies = req.getCookies(); String userId = admin; if (cookies != null) boolean flag=false; for (Cookie cookie : cookies) //查找名为userId的cookie if (Objects.equals(cookie.getName(), userId) Objects.equals(cookie.getValue(), admin)) flag=true; break; if(flag) System.out.println(---Filter:path:/*：欢迎管理员——doFilter); /*操作*/ else System.out.println(---Filter:path:/*：不是管理员——doFilter); /*操作*/ //下放 filterChain.doFilter(req,rsp); @Override public void destroy() System.out.println(---Filter:path:/*：结束过滤——destroy); 第二层过滤：过滤xss用户（xssFilter） @WebFilter(filterName = xss,value = /xss)public class xssFilter implements Filter @Override public void init(FilterConfig filterConfig) throws ServletException System.out.println(--Filter:path:/xss：启动成功——init); @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException System.out.println(--Filter:path:/xss：开始过滤——doFilter); //两步，判断与放行 HttpServletRequest req=(HttpServletRequest)servletRequest; HttpServletResponse rep=(HttpServletResponse)servletResponse; String payload = req.getParameter(payload); //1、判断(大小写不敏感 if(payload.toLowerCase().contains(script)) System.out.println(--Filter:path:/xss：XSS——doFilter); else //放行 System.out.println(--Filter:path:/xss：无注入——doFilter); filterChain.doFilter(req,rep); @Override public void destroy() System.out.println(--Filter:path:/xss：结束过滤——destroy); Servlet路由：xss（xss） @WebServlet(/xss)public class xss extends HttpServlet @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException resp.getWriter().append(h1hello Filter/h1); System.out.println(-web:path:/xss：hello); 测试如图 安全问题1、 作为一个“过滤器”不安全的时候可能就只有程序员过滤不完全，有逻辑漏洞的时候了 Listener Listener 是 Java Servlet 规范中的一部分，它提供了一种机制，使开发者能够编写监听器类来监听容器事件，并在事件发生时执行相应的逻辑。下面是常见的三种类型，由于是简单了解，所以只演示HttpSessionListener（会话监听器）的简单监听。 知识点 1、 常见的有三种 Listener ServletContextListener（上下文监听器）：用于监听 Web 应用程序的启动和关闭事件。 HttpSessionListener（会话监听器）：用于监听会话的创建和销毁事件。 ServletRequestListener（请求监听器）：用于监听请求的创建和销毁事件。 Code这里附上监听器和创建销毁监听器的关键代码 /** * 监听器 */@WebListenerpublic class ListenSession implements HttpSessionListener @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) System.out.println(---Listener:监听到了session创建---); @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) System.out.println(---Listener:监听到了session销毁---); /** * 销毁监听器 */@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException System.out.println(--Listener:销毁Session---); req.getSession().invalidate();/** * 创建监听器 */@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException //创建Session System.out.println(--Listener:创建Session---); req.getSession(); 测试结果 反射 Java反射是一种强大的机制，允许程序在运行时动态地获取类的结构信息（如字段、方法、构造函数等），并对其进行操作。反射广泛应用于框架设计（如Spring的依赖注入）和动态代理等场景。具体到 code 里就是一个对象的class类，Person.class 知识点 1、 反射其实和 mysql 的数据库 information_schema 很像，里面记录了所有的信息，而 java 提供了很多方法供你方便地拿取与调用而非敲搜索语句（），比如一个类，你可以通过反射获得这个类的所有信息，包括成员方法啊，构造方法啊，成员变量，当然也可以进行调用 2、 不看具体方法名而直接调用等特征让反射普遍用于框架设计或需要动态调整的场景里 3、 如果把存反编译数据的文件打开会发现是如图的乱码 Code由于几乎都是理论知识，直接在code里说明方法的作用如何获取class /** * 如何获取Class实例呢 */// 1、通过完整路径Class p1=Class.forName(com.classthree.demo_01.reflect.Person);// 2、通过类名Class p2=Person.class;// 3、通过类的实例Class p3=(new Person()).getClass();// 4、通过类加载器ClassLoader loader=ClassLoader.getSystemClassLoader();Class p4=loader.loadClass(com.classthree.demo_01.reflect.Person);//验证System.out.println(p1==p2);//trueSystem.out.println(p2==p3);//trueSystem.out.println(p3==p4);//true 如何-获得修改-成员变量（Field） /** * Class获取成员方法 * 共有就是共有，连默认都不算~ */Class cls= Person.class;// 获取公共成员变量数组Field[] g_fields=cls.getFields();System.out.println(---------------);System.out.println(Arrays.toString(g_fields));System.out.println(---------------);// 获取所有成员变量数组Field[] a_fields=cls.getDeclaredFields();System.out.println(Arrays.toString(a_fields));System.out.println(---------------);// 获取单个公共成员变量Field g_field=cls.getField(name);System.out.println(g_field);System.out.println(---------------);// 获取单个(所有)成员变量Field a_field=cls.getDeclaredField(nums);System.out.println(a_field);/** * 前面是获取，那么更改呢 */// 1、getPerson per=new Person();per.age=12;Field f=cls.getDeclaredField(age);System.out.println(former:+f.get(per));//former:12//2、setf.set(per,22);System.out.println(end:+f.get(per));//end:22 如何-获得使用-构造方法（Constructor） /** * 构造方法 * set并获得实例 */Class cls= Person.class;// 1、所有公共构造方法Constructor[] con1=cls.getConstructors();System.out.println(Arrays.toString(con1));System.out.println(---------------);// 2、所有构造方法Constructor[] con2=cls.getDeclaredConstructors();System.out.println(Arrays.toString(con2));System.out.println(---------------);// 3、单个公共构造方法Constructor con3=cls.getConstructor();//无参Person p1= (Person) con3.newInstance();System.out.println(---------------);// 4、单个构造方法，私有的话需要trueConstructor con4=cls.getDeclaredConstructor(String.class);//一参con4.setAccessible(true);// 利用构造方法构造出对象Person p2= (Person) con4.newInstance(Nailu);System.out.println(---------------); 如何-获得使用-成员方法（Method） /** * 获得成员方法 */Class cls= Person.class;// 获取公共成员方法数组 注意：包括继承的！Method[] g_methods=cls.getMethods();System.out.println(---------------);System.out.println(Arrays.toString(g_methods));System.out.println(---------------);// 获取所有成员方法数组Method[] a_methods=cls.getDeclaredMethods();System.out.println(Arrays.toString(a_methods));System.out.println(---------------);// 获取单个公共成员方法Method g_method=cls.getMethod(pub_test,int.class);System.out.println(g_method);System.out.println(---------------);Method g_method2=cls.getMethod(pub_test);//无参System.out.println(g_method2);System.out.println(---------------);// 获取单个(所有)成员方法Method a_method=cls.getDeclaredMethod(pub_test,int.class,String.class);System.out.println(a_method);System.out.println(---------------);Method a_method2=cls.getDeclaredMethod(pub_test,String.class,int.class);System.out.println(a_method2);System.out.println(---------------);/** * 方法的执行 * 浅浅写几个 */Person p1=new Person();a_method2.invoke(p1,456,123);//公共双参方法456+123 还有就是类Person public class Person public String name; int age; protected String gender; private String nums; public Person() System.out.println(公共无参); public Person(String name, int age) System.out.println(公共二参：+name+++age); private Person(String name) System.out.println(私有一参：+name); public void get() System.out.println(Person + name= + name + \\ + , age= + age + , gender= + gender + \\ + , nums= + nums + \\ + ); private void pri_test(int a) System.out.println(私有单参方法+a); private void pri_test(int a,String b) System.out.println(私有双参方法+a+++b); public void pub_test() System.out.println(公共无参方法); public void pub_test(int a) System.out.println(公共单参方法); public void pub_test(int a,String b) System.out.println(公共双参方法+a+++b); public void pub_test(String a,int b) System.out.println(公共双参方法+a+++b); Serializer Java序列化是将Java对象转换为字节序列的过程，而Java反序列化是将字节序列恢复为Java对象的过程。 知识点 1、 序列化就是把代码变成字节形式，易于保存（可保存到文件或数据库里）和网络传输 2、 反序列化漏洞，顾名思义就是在反序列化的时候出现的漏洞。比如网站反序列化你的序列化文件给你，那么就可以自己构造含有恶意代码的对象。（恶意代码可以在构造函数里，也可以在静态代码块里比如toString，还可以在方法里） Code这里先讲普遍的方式，在对象里加恶意代码。下面还有课上讲的利用特定类的配合进行带出 /** * 想要序列化这个对象就得先实现 Serializable 这个标记接口 */public class Person implements Serializable public String name; int age; protected String gender; private String nums; public Person() System.out.println(公共无参); /** * 无参构造函数测试 ac */// try // Runtime.getRuntime().exec(calc);// catch (IOException e) // throw new RuntimeException(e);// public Person(String name, int age) /** * 1、构造函数代码块隐式执行 * 前提是-序列化的对象-创建时调用的是这个构造方法 * =反序列化的时候弹窗 * */// try // Runtime.getRuntime().exec(calc);// catch (IOException e) // throw new RuntimeException(e);// this.name=name; this.age=age; System.out.println(公共二参：+name+++age); private Person(String name) System.out.println(私有一参：+name); @Override public String toString() /** * 2、静态代码块隐式执行 * =打印的时候弹窗 * */// try // Runtime.getRuntime().exec(calc);// catch (IOException e) // throw new RuntimeException(e);// return Person + name= + name + \\ + , age= + age + , gender= + gender + \\ + , nums= + nums + \\ + ; public void get() System.out.println(Person + name= + name + \\ + , age= + age + , gender= + gender + \\ + , nums= + nums + \\ + ); private void pri_test(int a) System.out.println(私有单参方法+a); private void pri_test(int a,String b) System.out.println(私有双参方法+a+++b); public void pub_test() System.out.println(公共无参方法); public void pub_test(int a) System.out.println(公共单参方法); public void pub_test(int a,String b) System.out.println(公共双参方法+a+++b); public void pub_test(String a,int b) System.out.println(公共双参方法+a+++b); /** * 原理是竞争反序列化函数里面的一个方法 readObject 从而执行 * 反编译代码测试 * =反序列化的时候弹窗 */ private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException // 执行恶意代码 Runtime.getRuntime().exec(notepad); //指向正确的readObject,这样就可以正常反序列化（了解） ois.defaultReadObject(); 利用 HashMap 类的方法 readobject（）结合 URL 类带出 /** * 当入口参数包含 readObject 也会同重写对象 readObject 方法一样执行 * 比如HashMap * * 方法调用如下： * Gadget Chain: * HashMap.readobject() * HashMap.putVal() * HashMap.hakh() * URL.hashCode() 访问 url 路径 */HashMapURL,Integer map_=new HashMap();URL url=new URL(http://temple.dnslog.cn);map_.put(url,1);String path2=url.txt;//序列化与反序列化Serializable(map_,path2);UnSerializable(path2); 安全问题1、 上面就是围绕漏洞来展开的，但是是可以防御的。比如 不使用原生的序列化使用更安全的json或xml使用白名单输入验证最小化使用（尽量不使用）权限最小化（确保应用程序以最小的必要权限运行）等及时更新程序以及安装补丁 （如有不恰当的地方欢迎指正哦 ~o(●’◡’●)o） 参考blogs： 【servlet的映射与在idea中的使用】 【JDBC 驱动加载原理解析】 【【Java 进阶篇】Java Listener 使用详解】","tags":["网课小迪","温习"],"categories":["课堂","笔记"]},{"title":"小迪23年-28~31——js简单回顾","path":"/2025/08/02/小迪23年-28~31——js简单回顾/","content":"b站小迪23年网安基础课程，28节——31节，js简单回顾 前端-js开发 课堂完结后欲复习巩固也方便后续-重游-故写此篇从实现功能过渡到涉及的相关知识点 知识点 1、 JS 是前端语言，是可以被浏览器“看到”的，当然也可以被修改啊，被浏览器禁用网页的 JS 功能啊之类的。所以一般都是前后端分离开发，前端只负责显示与提醒用户。 2、 JS 是可以在浏览器里调试的，断点之类的都行，浏览器里也有控制台可以执行命令。 3、 浏览器不可能看到所有的 JS 文件，但是断点也带来了其他可能，只要断在你想知道参数的地方，那么没有显示的 JS 文件也不行影响到你，毕竟你只需要它们运行而非一定得拿到源码。 登录验证 简单流程：（最初实验版）前端 js 发送用户名和密码给后端，后端判断是否正确后返回参数，js依据参数决定是否进行页面跳转与弹窗 分析问题： 1、 前端语言是可以看到的，是可以被改变的，所以不能给前端跳转页面的权力，只能做提醒，不然会导致安全问题。 前端语言应只供展示与简单提醒 Code:前端 js 部分代码如下： !-- 采用js传输，php验证 --body h3用户登录/h3 div label for=username用户名：/label input type=text class=username name=username required /divbr div label for=password密码：/label input type=password class=password name=password required /divbr button登录/button/body!-- //导入jquery --script src=./js/js/jquery-3.7.1.js/script!-- 都是键值对！！！ --script\t$(button).click(function() $.ajax( url: check_login.php, data: user:$(.username).val(), passwd:$(.password).val() , type: POST, dataType: json, success: function(data) console.log(data); if(data.info==1) alert(登陆成功！); // location.href=index.php; /** * 安全漏洞出现，原因：前端代码不可进行操作，只需要提示就可以了 * * 小写，哦~*/ else console.log(登陆失败！); , error: function(text) alert(登陆失败！); );\t);/script 文件上传 简单流程：前端 js 判断文件格式等是否正确，然后发送给后端 php 进一步处理文件。简单模拟了已下前端部分，并没有写后端 php。 分析问题： 1、 前端先做第一步判断减轻服务器压力，但是也容易被绕过，所以后端还是得判断一次（也许可以优化法子？） 2、 但是并没有赋予前端任何权利并没有安全问题，压力给到后端。 Code：前端部分 js 代码如下： body div class=upload-container h2上传文件/h2 form action=upload.php method=post enctype=multipart/form-data input type=file name=fileToUpload id=file onchange=check_upload(this.value) button type=submit上传文件/button /form /div/body!-- 使用js来实现前端的文件格式过滤 --script //文件后缀白名单 let list_write=[jpg,png,gif,jpeg,webp]; //文件上传时发生改变触发方法 function check_upload(file_name) //取出后缀 let idx=file_name.lastIndexOf(.); let val=file_name.substring(idx+1,file_name.length); if(list_write.indexOf(val)!=-1) console.log(文件格式无误); //将文件发送后端…… else //刷新网页取消文件输入 location.reload(true); alert(文件格式有误); /script 打包器webpack 基本的目录结构如下： D:\\VSCODE\\WEBPACK-DEMO│ package.json（版本控制及脚本配置）│ webpack.config.js（配置文件）│├─dist（打包后的成品code）├─node_modules（依赖包）└─src（存自己写的code）├─index.html└─index.js 接下来通过简单使用来复习功能，并引入其作用。 开始之前先复习一下其概念：Webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。它分析项目结构，找到 JavaScript 模块以及其他一些浏览器不能直接运行的扩展语言（如 Scss，TypeScript 等），并将其转换和打包为合适的格式供浏览器使用。 然后使其使用与感悟：就举个最简单的 js 方面的例子：一个html页面可能需要引入非常多的 js 文件，不但太多了不好维护，也会导致访问的速度变慢，为了解决这一问题，可以用打包器 webpack 将任意多个 js 文件打包成一个或几个 js 文件。流程大致如下：1、打包器分析 js 文件之间的依赖关系（通过importrequire语句）2、构建依赖图3、打包、优化、合并成一几个 JS 文件 一、 新建文件夹 ‘js’，存放两个 js 文件代码分别如下: function divide(a,b) return a-b;export default divide; export default function add(a,b) return a+b; 二、 在 src 目录下新建一个 JS 文件用于联系多个 JS 文件（上面两） import one from ../js/_1;import two from ../js/_2;console.log(one(1,2))console.log(two(1,2)) 三、 配置 webpack.config.js 文件如下 const path = require(path);module.exports = mode:development,//开发模式 // mode:production 生产模式 entry: ./src/index.js,//入口文件 output: filename: bundle.js,//结果文件 path: path.resolve(__dirname, dist)//结果文件的位置 , 知识点 1、 上面配置 code 中的 mode开发模式用于网站开发过程中，生产模式用于网站部署后。至于弄混会咋样，如图，源码漏泄给浏览器 四、 执行打包命令 首先在 package.json文件里添加下面代码，然后移动终端的路径到webpack根目录下，运行命令npm run build scripts: build:webpack 这里也贴上两种模式产生的结果 JS 文件代价量的区别 生产模式code： (()=use strict;console.log(1-2),console.log(3))(); 开发模式code：是的，1行和100行的区别 /* * ATTENTION: The eval devtool has been used (maybe by default in mode: development). * This devtool is neither made for production nor for readable output files. * It uses eval() calls to create a separate source file in the browser devtools. * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/) * or disable the default devtool with devtool: false. * If you are looking for production-ready output files, see mode: production (https://webpack.js.org/configuration/mode/). *//******/ (() = // webpackBootstrap/******/ use strict;/******/ var __webpack_modules__ = (/***/ ./js/_1.js:/*!******************!*\\ !*** ./js/_1.js ***! \\******************//***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) = eval(__webpack_require__.r(__webpack_exports__); /* harmony export */ __webpack_require__.d(__webpack_exports__, /* harmony export */ \\default\\: () = (__WEBPACK_DEFAULT_EXPORT__) /* harmony export */ ); function divide(a,b)\\r return a-b;\\r \\r /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (divide); //# sourceURL=webpack:///./js/_1.js? );/***/ ),/***/ ./js/_2.js:/*!******************!*\\ !*** ./js/_2.js ***! \\******************//***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) = eval(__webpack_require__.r(__webpack_exports__); /* harmony export */ __webpack_require__.d(__webpack_exports__, /* harmony export */ \\default\\: () = (/* binding */ add) /* harmony export */ ); function add(a,b)\\r return a+b;\\r //# sourceURL=webpack:///./js/_2.js? );/***/ ),/***/ ./src/index.js:/*!**********************!*\\ !*** ./src/index.js ***! \\**********************//***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) = eval(__webpack_require__.r(__webpack_exports__); /* harmony import */ var _js_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/_1 */ \\./js/_1.js\\); /* harmony import */ var _js_2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../js/_2 */ \\./js/_2.js\\); \\r \\r \\r console.log((0,_js_1__WEBPACK_IMPORTED_MODULE_0__[\\default\\])(1,2))\\r console.log((0,_js_2__WEBPACK_IMPORTED_MODULE_1__[\\default\\])(1,2)) //# sourceURL=webpack:///./src/index.js? );/***/ )/******/ );/************************************************************************//******/ // The module cache/******/ var __webpack_module_cache__ = ;/******/ /******/ // The require function/******/ function __webpack_require__(moduleId) /******/ // Check if module is in cache/******/ var cachedModule = __webpack_module_cache__[moduleId];/******/ if (cachedModule !== undefined) /******/ return cachedModule.exports;/******/ /******/ // Create a new module (and put it into the cache)/******/ var module = __webpack_module_cache__[moduleId] = /******/ // no module.id needed/******/ // no module.loaded needed/******/ exports: /******/ ;/******/ /******/ // Execute the module function/******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__);/******/ /******/ // Return the exports of the module/******/ return module.exports;/******/ /******/ /************************************************************************//******/ /* webpack/runtime/define property getters *//******/ (() = /******/ // define getter functions for harmony exports/******/ __webpack_require__.d = (exports, definition) = /******/ for(var key in definition) /******/ if(__webpack_require__.o(definition, key) !__webpack_require__.o(exports, key)) /******/ Object.defineProperty(exports, key, enumerable: true, get: definition[key] );/******/ /******/ /******/ ;/******/ )();/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand *//******/ (() = /******/ __webpack_require__.o = (obj, prop) = (Object.prototype.hasOwnProperty.call(obj, prop))/******/ )();/******/ /******/ /* webpack/runtime/make namespace object *//******/ (() = /******/ // define __esModule on exports/******/ __webpack_require__.r = (exports) = /******/ if(typeof Symbol !== undefined Symbol.toStringTag) /******/ Object.defineProperty(exports, Symbol.toStringTag, value: Module );/******/ /******/ Object.defineProperty(exports, __esModule, value: true );/******/ ;/******/ )();/******/ /************************************************************************//******/ /******/ // startup/******/ // Load entry module and return exports/******/ // This entry module cant be inlined because the eval devtool is used./******/ var __webpack_exports__ = __webpack_require__(./src/index.js);/******/ /******/ )(); express实现服务端 服务器，也就是访问特定ip与端口会返回特定数据由此1、模拟网页刷新（渲染特定网页）2、模拟网页传输用户名密码需要连接数据库并返回结果3、依据get、post方式不同返回不同（路由） 由于是简单模拟，所以都集合在了一个server.js里，还有一个返回渲染网页用的html文件。 html 文件为渲染用登录页面，code： !DOCTYPE htmlhtml lang=zh-CNhead meta charset=UTF-8 title登录页面/title style body display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; .login-form padding: 20px; border: 1px solid #ccc; border-radius: 8px; width: 300px; .error-message color: red; display: none; /style/headbody form action=http://127.0.0.1:3001/login method=POST h3用户登录/h3 div label for=username用户名：/label input type=text id=username name=username required /div div label for=password密码：/label input type=password id=password name=password required /div input type=submit value=登录 /form/body/html server.js文件code： // 引入模块const express = require(express);const bodyParser = require(body-parser);const mysql = require(mysql);// 创建一个express应用const app = express();// 定义端口号const port = 3001;// 提供静态文件服务// app.use(express.static(public));// 解析 application/x-www-form-urlencoded 数据app.use(bodyParser.urlencoded( extended: false ));// 初始页面app.get(/,(req, res) = // res.send(GET请求成功！); //还可以渲染（返回）html文件！！ res.sendFile(__dirname+/html/login.html););// 1、get 方式传输表单数据app.get(/login,(req, res) = //参数获取 const u=req.query.username; const p=req.query.password; //连接数据库…… //判断 if(u==admin p==123456) res.send(欢迎管理员！get); else res.send(闲杂人等不得入内！get); );// 2、post 方式传输表单数据app.post(/login,(req, res) = //参数获取 const u=req.body.username; const p=req.body.password; //数据库设置 const connection = mysql.createConnection( host : localhost, user : root, password : password, database : user_all, port :3307 ); //连接数据库 connection.connect((error)= if(error) console.log(连接失败); else console.log(连接成功); ) //语句 let sentence=SELECT * FROM admin where username=+u+ and password=+p+; console.log(sentence); connection.query(sentence, (error, results, fields)= if(error)console.log(数据库连接失败) console.log(results); try //判断 if(u==results[0][username] p==results[0][password]) res.send(欢迎管理员！post); else res.send(闲杂人等不得入内！post); catch console.log(语句有误！); ); // //判断 // if(u==admin p==123456) // res.send(欢迎管理员！post); // else // res.send(闲杂人等不得入内！post); // );// 启动服务器并监听指定端口app.listen(port, () = console.log(`Server is running on http://localhost:$port`);); （如有不恰当的地方欢迎指正哦 ~o(●’◡’●)o） 参考blogs： 【webpack超详细教程，学webpack看这一篇就够了！（上）】 【【Webpack】三种模式详解】 【Webpack三种打包方式：（以下所有命令都是windows下执行的）】","tags":["网课小迪","温习"],"categories":["课堂","笔记"]},{"title":"小迪23年-22~27——php简单回顾（2）","path":"/2025/08/02/小迪23年-22~27——php简单回顾（2）/","content":"b站小迪23年网安基础课程，22节——27节，php简单回顾（2） 非原生开发 课堂完结后欲复习巩固也方便后续-重游-故写此篇从实现功能过渡到涉及的相关知识点 前端模板功能 1、有点前后端分离的思想。写好前端模板代码后由后端语言去替换相应的部分达到模板的作用。一般有两种实现实现方式：原生与第三方。2、code比如h1 class=news-title第nums个新闻：title/h1（原生实现）3、简单流程：引入模板 - 导入数据库数据 - 创建要替换的模板变量与替换值的对应关系 - 依据关系赋值给指定模板（第1、2步可换位置） 原生知识点 1、 前端模板代码就和普通html一样写，就是在需要替换的地方换成only_name就想上面一样。 2、 想要在 php 语言中实现框架的识别与引入，在替换前就得先设置好路径，语法如下: //想写好模板，然后替换并在这里显示（执行eval$template=file_get_contents(realative_path/name_framework.html);//替换结束后还需要执行下面语句//输出值将被赋给指定的模板变量eval(?.$template); code原生简单模拟的代码并不复杂，如下: index.html !DOCTYPE htmlhtml lang=zh-CNhead meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 title新闻页面/title style body font-family: Arial, sans-serif; margin: 20px; padding: 0; background-color: #f4f4f9; .news-article background-color: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); margin-bottom: 20px; overflow: hidden; .news-header padding: 15px; background-color: #007bff; color: white; .news-title font-size: 24px; margin: 0; .news-author font-size: 14px; color: #ccc; .news-content padding: 15px; .news-image width: 100%; height: auto; /style/headbodydiv class=news-article div class=news-header h1 class=news-title第nums个新闻：title/h1 p class=news-author作者：author/p /div img src=img alt=图片 class=news-image height=300 width=100 div class=news-content pcontent/p /div/div/body/html index.php 如下 ?php//链接数据库include ../config.php;//想写好模板，然后替换并在这里显示（执行eval$template=file_get_contents(./index.html);//语句$id=$_GET[id] ?? 2;$sentence=select * from news where id=$id;//执行并接收返回if(!($news=mysqli_query($mysqli_connect,$sentence)))\techo 数据库链接失败！;;//显示$search=[nums,title,author,content,img];while ($rows=mysqli_fetch_row($news)) // echo h1标题：$rows[1]/h1;\t// echo h3作者：$rows[2]/h3;\t// echo div$rows[3]/div;\t// echo img src=$rows[4] weight=200 height=400;\t//直接替换和执行\t$template=str_replace($search, $rows, $template);\teval(?.$template);? 安全问题1、 分析：自写的代码并连接数据库如果对安全问题不重视，容易产生 sql注入漏洞与任意代码执行 第三方模板（以smarty为例） 由于是简单使用，所以并没有了解很深，这里简单说下区别。1、只需要在配置文件里设置数据库的配置就可以任意连接数据库等，自带一些过滤。2、依据 smarty 语法写好的php代码在运行时会被解析成模板php文件供中间件解析与浏览器显示 代码都是一些实验的，并没有小项目之类的，就简单说一下一些语法： 1、 和原生一样的设变量 + 替换。 变量：$only_name，就是里面加了个 $单个替换：$smarty-assign(Name, 开炮！, true); 2、 这里用语法里的 display() 函数来复习运行php文件内部流程： 目录结构 code： // 在代码最后调用display()，里面是前端模板以template文件为根的相对路径$smarty-display(index.tpl); 当调用 display() 函数时，Smarty将执行以下步骤： 1、尝试将传递给 display() 函数的模板路径解析为绝对路径。2、尝试从缓存中获取已编译的模板，如果存在，则跳至第6步。3、如果缓存中不存在已编译的模板，则Smarty会编译模板，生成PHP代码，并将其缓存到磁盘上。4、Smarty会将编译后的代码包含在当前PHP脚本中，并执行它。5、输出编译后的模板内容。6、Smarty清理各种临时变量和句柄，完成页面渲染。 安全问题1、 第三方模板，如果使用的是由历史漏洞的版本那么就会发生危险，比如 CVE-2021-26120 ,smarty-3.1.38就会有这个漏洞，smarty-3.1.39就修复了。 2、 如果并没有按照模板的语法来写而是自己写的话那么也可能会在一些地方产生漏洞。 框架（以 thinkphp 为例） PHP Web框架是用于构建Web应用程序的工具和库集合，旨在简化开发过程，提高代码质量和开发效率。也就是说不管是上篇的原生开发里的部分，还是上面的模板部分（内置有smarty），框架都可以很轻松的包含进去，并设置了特定语法，增强代码的安全性，让开发人员致力于代码开发而非其他地方。 这里由-文件上传功能-和-数据库操作-来引入复习内容 前置：路由访问（以小皮为例）知识点 一、路径路由 1、 想要运行 thinkphp 得先在小皮里新建一个以 thinkphppublic 为根目录的网站，访问对应 ip和端口会自动访问 publicindex.php 文件。 2、 或者在 application文件里新建 controllerIndex.php，在里面创建index方法，那么首页也会从index方法里读取返回值并显示。 3、 那么想要访问其他模板呢？ 以上面首页为例，除了默认访问之外还可以通过 “模块名控制器名方法名” 来访问，所以是127.0.0.1:81/index.php/index/index/index，如图，第一个 index 为 application 下的模块名，第二个index为模块下 controller 里的首字母大写（规范写法）的控制器名：Index，最后是 index.php 里的方法名 index; 二、参数路由 1、 thinkphp 不但支持参数的 get方式传递?id=1，还支持路由传递/id/1，想实现这种方式code如下： ?php//入口namespace app\\index\\controller;//引入use think\\Controller;use think\\Request;//class Index extends Controller\t//首页 public function index() //自控显示 return 123; //框架传递参数方式 public function test1() return $this-request-param(name); //原生传递参数方式 public function test2() $name=$_GET[name]; return $name; 文件上传功能 大致流程：用表单简单写一个文件上传，同样的访问路径接收，然后保存文件 表单： form action=/index.php/test/test/upload enctype=multipart/form-data method=postinput type=file name=image / br input type=submit value=上传 / /form 接收： ?phpnamespace app\\test\\controller;use think\\Controller;use think\\Request;class Test extends controller //文件上传 public function upload() // 获取表单上传文件 例如上传了001.jpg $file = request()-file(image); // 移动到框架应用根目录/uploads/ 目录下 //大小限制，类型限制 $info = $file-validate([size=156780000,ext=jpg,png,gif])-move( ../uploads); if($info) // 成功上传后 获取上传信息 // 输出 jpg echo $info-getExtension().br; // 输出 20160820/42a79759f284b767dfcb2a0197904287.jpg echo $info-getSaveName().br; // 输出 42a79759f284b767dfcb2a0197904287.jpg echo $info-getFilename(); else // 上传失败获取错误信息 echo $file-getError(); 数据库操作 也容易猜，只需配置文件里设置就好了：在 主文件下configdatabase.php里，如下图：还有就是如果需要引用数据库，那么就在上面加上 use think\\Db; 引入就好了。 示例代码如下： ?phpnamespace app\\index\\controller;use think\\Db;use think\\Controller;use think\\Request;class Index extends Controller public function index() //不用——全是漏洞！ $id=$_GET[id]; $data=Db::query(select *from news where id=$id); //用一半，有漏洞 $ids=$this-request-param(id); // 1、安全点写法——参数通过数组形式传递，可防sql注入 $data=Db::query(SELECT * FROM news WHERE id=:ids,[ids=$ids]); // 2、原始写法 // $data=Db::query(select *from news where id=$id); //内置写法，无漏洞（） // $id=$this-request-param(id); // $data=Db::table(news)-where(id,$id)-find(); // return $data; return json($data); // return 123; MVC模型 MVC 是一种 设计开发 模式。MVC 是一种软件架构模式，将应用程序分为三个主要部分：模型（Model）：负责数据的处理和业务逻辑。视图（View）：负责数据的展示和用户界面。控制器（Controller）：负责接收用户输入，调用模型和视图完成用户请求。 自我理解：上面说路由的时候说到了如何访问，浅谈框架的时候也说明了内置有 smarty，那么如何使用 smarty呢？ 市面上普遍使用的是 MVC模式，就是下图。模块里面 controller 和 view，每一个控制器都有一个 view 模块，里面就是相对应的 html 前端文件。 这里举一个 test 模块里 Test.php 控制器里 vv 方法的例子： //view：框架上的html与php的配合public function vv() // 模板变量赋值 // $this-assign(name,ThinkPHP); // $this-assign(email,thinkphp@qq.com); // 或者批量赋值 $this-assign([ name = ThinkPHP, email = thinkphp@qq.com ]); //模板输出:默认为空就是方法名，可修改 return $this-fetch(index); 安全问题1、 不使用内置代码写法 比如数据库操作里接收 id 值，如果你用原生的$_GET[‘id’]的话就会有sql注入的问题。因为框架是有内部过滤的，如果不用定义语法就无法进行过滤。 2、 thinkphp还有老的连接数据库的语句，原理也是拼接。 老危险的： //最原始Db.query(select * from news where id=$ids);//升级语句,参数通过数组形式传递Db::query(SELECT * FROM news WHERE id=:ids,[ids=$ids]);//:ids是命名占位符，用于绑定参数，防止 SQL 注入 新安全的：Db::table(news)-where(id,$id)-find(); 3、 版本漏洞 作为第三方开源的产品，可能会有历史漏洞，造成安全问题。 （如有不恰当的地方欢迎指正哦 \\x7eo(●’◡’●)o） 参考blogs: 【smarty模板中display函数的原理】 【PHP中使用Smarty模板目录结构配置】 【thinkPHP框架详解+部署】 【smarty完全中文手册】","tags":["网课小迪","温习"],"categories":["课堂","笔记"]},{"title":"小迪23年-22~27——php简单回顾（1）","path":"/2025/08/01/小迪23年-22~27——php简单回顾（1）/","content":"b站小迪23年网安基础课程，22节——27节，php简单回顾（1） 原生开发 课堂完结后欲复习巩固也方便后续-重游-故写此篇从实现功能过渡到涉及的相关知识点 留言板功能 简单流程：浏览器访问 - 后端php代码接收、处理请求，并连接数据库查询 - 数据库返回数据给php - 后端响应数据给浏览器 知识点 1、 php文件可以兼容http和php 2、 浏览器正确显示php文件：由-中间件-解析执行php并把结果返回给浏览器显示 3、 浏览器“看不到”php代码（后端语言） 连接数据库一、 另建一个 config.php 文件作为数据库连接的全局配置文件，只在需要的地方导入就好了。 //导入数据库连接require config.php;//或者include config.php; 二、 config.php 代码如下 !-- 数据库连接的全局配置文件 --?php// 连接数据库$dbhost=localhost:3306;$dbuser=db_name;$dbpwd=db_pwd;$dbname=tb_name;// 会返回mysql$mysqli_connect=mysqli_connect($dbhost,$dbuser,$dbpwd,$dbname);? 三、 数据库基本知识复习 1、 查询 select * from user where id=1; 2、 删除 delete from user where id10; 3、 插入 //全插入insert into user values(1,Nailu,22),(2,张三,39)//插部分insert into user(id,username) value(3,李四); 4、 更新 update user set id=250,username=test_name where id=3; 后端php一、 接收浏览器数据 知识点 1、 php的-超级全局变量-所有作用域都可访问 2、 一般利用超级全局变量 $_POST(v_name)和$_GET(v_name)来接收数据 3、 还有一些超级全局变量 $GLOBALS（变量）$_SERVER（请求的信息）$_REQUEST（响应的信息）$_FILES（文件）$_ENV（服务器端环境) - $_ENV[‘pwd’]$_COOKIE（鉴权）$_SESSION（鉴权） 二、 处理并显示给浏览器 代码如下： ?php//导入数据库连接require config.php;// 显示function show_p($i,$del) echo $del.br; //sql语句 $yuju=select * from gbook;; ;//得到数据 if($res=mysqli_query($i,$yuju)) // 是否还有数据 while($array=mysqli_fetch_row($res)) echo hr; echo 用户名：.$array[1].br; echo 内容.$array[2].br; echo 评论时间：.$array[3].br; echo ip地址：.$array[4].br; if ($del==del) echo a href=./del.php?id=$array[0]删除/a.br; echo $array[0]; else echo 连接数据库显示留言失败！; // 添加function add_p($i) //获取必须数据 $name=$_POST[uname]; $contents=$_POST[content]; $ip=$_SERVER[REMOTE_ADDR]; $t =date(Y-m-d H:i:s, intval($_SERVER[REQUEST_TIME])); // 写入数据 if (!empty($name)!empty($contents)) //sql语句（拼接） $sql=insert into gbook value(0,$name,$contents,$t,$ip); //执行-第一个数据库，第二个表 if(mysqli_query($i,$sql)) echo scriptalert(评论成功！)/script; else echo scriptalert(评论失败\\\\\\x7e)/script; show_p($mysqli_connect,x);add_p($mysqli_connect);? 安全问题1、 水平越权漏洞 当不是每个网页每次请求都验证 Cookie 或者 Session 或者 token 而有依据参数判断的话，就好发生水平越权，用户可以暴力破解出管理员的参数值从而控制网页。 2、 XSS（跨站脚本攻击） 观察，是留言板，那么用户在评论的内容里输入php代码是都会被执行呢？关键在于是否过滤，还是直接写入数据库。可以用第三方组件，可以自己写code，也可以是混合。 3、 第三方富文本编辑器组件的漏洞 比如留言板需要图片呐，文件呐等更丰富的输入形式，那么就可以用上第三方的留言框，但是如果下载的版本有历史漏洞的话那么就会连带着网站也有了漏洞 后台验证功能【以 token 为例】 就如上面-连接数据库-里的-安全问题-一样，如果没有每个网站每次请求都鉴权那么就会-水平越权-。那么三种方式哪种安全呢，各自有啥特点以及适合哪些领域呢？ 知识点 1、 鉴权技术 Cookie：放在浏览器里，每次请求附带（可加密）Session：放在服务端，每次请求附带 sessId 在cookie里Token：最新也是最安全的技术，每次请求都有唯一 token，通常的话是放在session里面，防爆破，防 csrf（跨站请求伪造） 2、 Session 小部分 session_start();是php里启动sesson服务的语句，只要你请求里cookie中附带SESSID那么就可以“联系”上 id 唯一的sesison文件并可以读取内容。所以不需要用户开发服务端的时候去写code。 Session 文件的默认保存路径在 php.ini 文件里的 session.save_path 上改。 3、 token 部分 为了让每次表单提交都是唯一的，里面得添加每次刷新变化的 token 值（服务端也同步刷新）。如下。 input type=hidden name=privatetoken value=?php echo $token;? / 4、 @作用@的作用是抑制出错时信息的显示，比如 $file = @file(non_existent_file);$name = keyword at in PHP;echo $name; 没有@结果是 有@： 也没特别的流程，直接上代码：首先是登录页面的代码，一个简单的表单提交给 index-t.php ?php@session_start();$token=md5(getrandcode());$_SESSION[token] = $token;function getrandcode() $str =array(0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h); $res=; for($i=0;$i4;$i++) $rand=mt_rand(1,17); $res .=$str[$rand]; return $res;?/html!DOCTYPE htmlhtml lang=zh-CNhead meta charset=UTF-8 title登录页面/title style body display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; .login-form padding: 20px; border: 1px solid #ccc; border-radius: 8px; width: 300px; .error-message color: red; display: none; /style/headbody form class=login-form method=post action=./index-t.php h3用户登录/h3 div label for=username用户名：/label input type=text id=username name=username required /div input type=hidden name=privatetoken value=?php echo $token;? /br div label for=password密码：/label input type=password id=password name=password required /div input type=submit value=登录 /form/body/html 然后是首页的代码，由于是简单模拟，所以当 token 正确后直接把 token 删了，没有写刷新后的 token 赋值之类的\\x7e。code： ?php //启动session服务！！！cookie里面有 PHPSESSID 所以 @session_start(); //开始判断 if($_POST) echo 1.$_SESSION[token].br; echo 2.$_POST[privatetoken].br; if ($_POST[privatetoken] == $_SESSION[token]) //删除 session 里面的token unset($_SESSION[token]); //打印内容 echo h1后台首页/h1; echo 欢迎.$_SESSION[username].，这里是用户页面; else echo novalite; else //回去吧你！ header(Location: http://localhost/class_1/admin/login-t.php); //确保重定向后，后续代码不会被执行 exit(); ? 安全问题1、 cookie窃取 和 Session劫持（会话劫持） 当 kacker 通过莫种方式拿到了 cookie 或者 SESSID 的话那就可以模拟该用户发送请求。 文件管理功能 php的文件操作无非文件读取、接收、修改、保存一类。跟着课堂写了一个浏览器显示操作的文件编辑器。能够下载、上传、修改、删除文件。 知识点 1、 文件管理系统的可访问目录修改 可以在 php.ini 文件里修改 open_basedir，一个点”.”为当前目录;也可以在代码里修改ini_set(open_basedir,.);。 2、 文件下载就是请求包里面的参数不同 设置下载请求header(“Content-type:applicationoctet-stream”);header(“Accept-Length:”.filesize($file_path));header(“Content-Disposition: attachment; filename”.$file_path); 3、 读取 form 表单传送过来的文件 需要用到超级全局变量 $_FILES,实例代码如下（不完整 //上传form action=upload.php method=post enctype=multipart/form-data input type=file name=fileToUpload id=file button type=submit上传文件/button/form//读取$name=$_FILES[fileToUpload][name];$type=$_FILES[fileToUpload][type];$size=$_FILES[fileToUpload][size];$tmp_name=$_FILES[fileToUpload][tmp_name];$error=$_FILES[fileToUpload][error]; 文件管理系统 由于并不复杂，就集合与一个php文件中，有些简陋并没有考虑到只包含文件或者只包含文件夹的情况。就只是遍历显示\\x7e ?php/** * ====== * ======文件夹的读取与保存操作 * ======*/// 注意：打开的是文件夹，所以最后是有 / 的$dir=$_GET[path] ?? .;//输出数组$file_list;//显示函数function show_file($path)\tglobal $file_list;\t$f=opendir($path);\t//当前目录是还有文件或者文件夹\twhile(($s=readdir($f))!=false) //过滤点 if($s!=. $s!=..) //文件类型(dir,file)和路径 $file_path=$path/$s; if(file_exists($file_path)) $file_type=filetype($file_path); else echo 文件路径--.$file_path.--不存在; //二维数组保存 $file_list[$file_type][]= array( file_name = $s, file_size = round(filesize($file_path)/1024), file_time = date(Y-m-d H:i:s,filemtime($file_path)), file_path = $file_path );\t/** * ====== * ======路径的过滤操作 * ======1、php自带的ini文件里设置最大路径 * ======2、php的可访问目录函数把范围框在这个文件夹 * ======ini_set(open_basedir,_DIR_)*/ini_set(open_basedir,.);if(is_dir($dir))\tshow_file($dir);else\tdir(路径请求错误！不是文件夹路径！);/** * ====== * ======文件的编辑，删除，下载函数 * ====== * ======*///删除函数function delete($file_path)\t//使用php自带函数删除，避免使用system()系统\t// system(del $file_path);\tunlink($file_path);//下载函数function download($file_path)\t//设置请求\theader(Content-type:application/octet-stream);\theader(Accept-Length:.filesize($file_path));\theader(Content-Disposition: attachment; filename=.$file_path);//编辑的显示函数function edit_file_show($file_path)\t//在当前页面显示一个框和一个提交按钮\t$content=file_get_contents($file_path);\techo form name=form1 method=post action=;\techo 文件名：.$file.br;\techo 文件内容：br;\techo textarea name=eidt_code style=resize:none rows=50 cols=50.$content./textareabrbr;\techo input type=submit name=submit id=submit value=提交br;\techo /form;//编辑的写入函数function edit_file_action($file_path,$content)\techo file::.$content;\t$f=fopen($file_path,w+);\tfwrite($f,$content);\tfclose($f);//选择$action=$_GET[action] ?? ;/** * 这里对路径一点判断都没有！会有任意文件读取漏洞！ * * 好吧，其实不会有，就是把报错变成下载的包了，意外 * 访问包含了好多啊~~ * * */$file=$_GET[file_path] ?? ;switch ($action) case del: delete($file); break;\tcase down: download($file); break;\tcase edit: edit_file_show($file); break;\tdefault: break;if(isset($_POST[eidt_code]))edit_file_action($file,$_POST[eidt_code]);?!-- ============前端的显示部分====== --!DOCTYPE htmlhtml lang=zh-CNhead/headbody table thead tr th类型/th th名字/th th日期/th th路径/th th大小/th th操作/th /tr /thead !-- 循环文件夹 -- ?php foreach ($file_list[dir] as $v): ? tbody tr tdimg src=./img/dir.webp height=20 width=20 /td td?php echo $v[file_name]; ?/td td?php echo $v[file_time]; ?/td td?php echo $v[file_path]; ?/td td?php echo $v[file_size]; ?/td tda href=?path=?php echo $v[file_path] ?打开/a/td /tr ?php endforeach; ? !-- 循环文件 -- ?php foreach ($file_list[file] as $v): ? tr tdimg src=./img/file.png height=20 width=20 /td td?php echo $v[file_name]; ?/td td?php echo $v[file_time]; ?/td td?php echo $v[file_path]; ?/td td?php echo $v[file_size]; ?/td td a href=?action=delfile_path=?php echo $v[file_path] ?删除/a a href=?action=downfile_path=?php echo $v[file_path] ?下载/a a href=?action=editfile_path=?php echo $v[file_path] ?编辑/a /td /tr ?php endforeach; ? /tbody\t/table/body/html 安全问题1、 目录遍历 如果没有设置-可访问目录-就会出现 2、 任意文件上传、删除、包含、下载 上传没有过滤：传一句话木马还没有重命名文件：文件包含执行木马，控制网站没有设置-可访问目录-：任意删除、下载 措施： 输入验证限制文件类型过滤危险字符：str_replace等。配置open_basedir：可访问目录。升级PHP版本重命名上传文件：防止被读取。设置白名单：权限管理：最小化allow_url_include和allow_url_fopen的权限。","tags":["网课小迪","温习"],"categories":["课堂","笔记"]},{"title":"kali安装失败-选择并安装软件包-一步到位","path":"/2025/07/25/kali安装失败-选择并安装软件包-一步到位/","content":"使用kali官网配置好的虚拟机文件跳过使用iso镜像创建kali虚拟机的过程中遇到的问题 起因为了尝试 “rm -rf *“ 的威力导致的kali无用（心虚），需要重新装一个。 但是吧，如题，在这一步卡住了，网上找blog【kali 安装步骤失败，选择并安装软件包，失败解决方法 “换源”_kali安装步骤失败 选择并安装软件-CSDN博客】，但是并没有解决，我进入tty2终端后”nano etcaptsources.list”发现里面是空的！就算写上去也没用，折腾好久也没搞定。\\x7e~有图省事直接拿自己csdn账号的图(~~ 解决最后还是选择简（逃）单（课）方式——直接下载别人安装好的虚拟机文件压缩包！依旧是kali官网上的【Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution】 点击download进入下载界面如图： 这次选择右边的卡片，然后按照自己的虚拟PC软件选就好了。一般下载上面的，下面的是字面意思每周更新所以不是稳定版，一般用户直接点下载图标就好了。【下载图标右边的三是啥最下面会有解释，最终下载的都是一样的压缩包！不想麻烦直接点下载就好了】 下载完成后放到对应位置就可以解压缩了，这是可以直接使用虚拟PC软件打开的，这里用VM浅浅演示一下。 首先打开VM，点击打开虚拟机，找到对应的文件位置，进去发现一个VM的.vmx启动文件，双击打开就好了。【vmx是啥最下面会提】 左下角可以看到账户名和密码都是kali，ok，现在就可以启动启动了！ Learn Time!1、 演示里VM打开的.vmx文件是啥？ 其实从windows对.vmx文件的解释也可以看出来是配置文件（用记事本打开试试） 2、 下载图标右边第一个“torrent”是啥？ 其实这就是常说的 BT种子磁力链接 文件，直接点击下载会发现只是个几百k的小文件，和我们直接下载的压缩包就多了个.torrent（当然名字并不重要）。可以在网盘或者讯飞用来添加BT下载任务来下载，下载速度挺快的，如果电脑直接下载速度感人的话可以试试~ 想简单了解可以移步【torrent（BT种子）文件的简单介绍与使用-CSDN博客】 3、 下载图标右边第二个“docs”是啥？ 点击发现是个链接，并不是“第三种下载方式”。毕竟 “docs” 翻译过来就是 “文档” 的意思。里面也是如其意的是帮助你下载的【官方帮助文档】，四个虚拟pc软件的文档也都应当的在一个网址上。 4、 最后一个“sum”是啥？ 点击看卡片翻转过来显示了一串字母数字组合【SHA-256哈希值】。其实是用来帮你判断下载的.7z文件是否是完整的。在linux里有个命令可以查看文件的【SHA-256哈希值】sha256sum filename，如下。不过现在的话基本不会出现下载的文件不完整的事情就是。 命令详情可以移步【https://zhuanlan.zhihu.com/p/689918610】 （如有不恰当的地方欢迎指正哦 ~o(●’◡’●)o） 参考博客： 【bios里的vmx是什么意思_mob649e8169ec5f的技术博客_51CTO博客】 【torrent是什么文件？torrent文件怎么打开？ - 系统之家】 【BT种子(torrent)磁力链接的简介与使用 - 哔哩哔哩】","tags":["kali","bug"],"categories":["随笔","实操"]},{"title":"about","path":"/about/index.html","content":"你好，旅行者"},{"path":"/friends/index.html","content":"我的友链 .friends-container { display: flex; flex-wrap: wrap; gap: 20px; padding: 20px; } .friend-card { display: flex; align-items: center; border: 1px solid #ddd; border-radius: 8px; padding: 15px; width: calc(33.333% - 20px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); transition: transform 0.2s; } .friend-card:hover { transform: translateY(-5px); } .friend-avatar { width: 60px; height: 60px; border-radius: 50%; margin-right: 15px; } .friend-info { flex-grow: 1; } .friend-name { font-size: 1.2em; font-weight: bold; margin: 0; } .friend-descr { font-size: 0.9em; color: #555; margin-top: 5px; } document.addEventListener('DOMContentLoaded', () => { const friendsListElement = document.getElementById('friends-list'); const jsonUrl = 'https://dl668.github.io/friends/friends.json'; fetch(jsonUrl) .then(response => { if (!response.ok) { throw new Error('Network response was not ok'); } return response.json(); }) .then(data => { data.forEach(friend => { const card = document.createElement('a'); card.href = friend.link; card.target = \"_blank\"; card.className = \"friend-card\"; const avatar = document.createElement('img'); avatar.src = friend.avatar; avatar.alt = `${friend.name} 的头像`; avatar.className = \"friend-avatar\"; const info = document.createElement('div'); info.className = \"friend-info\"; const name = document.createElement('p'); name.className = \"friend-name\"; name.textContent = friend.name; const descr = document.createElement('p'); descr.className = \"friend-descr\"; descr.textContent = friend.descr; info.appendChild(name); info.appendChild(descr); card.appendChild(avatar); card.appendChild(info); friendsListElement.appendChild(card); }); }) .catch(error => { console.error('There has been a problem with your fetch operation:', error); friendsListElement.innerHTML = '无法加载友链数据。'; }); });"},{"title":"friends","path":"/friends/index.html","content":".friends-container { display: flex; flex-wrap: wrap; gap: 20px; padding: 20px; } .friend-card { display: flex; align-items: center; border: 1px solid #ddd; border-radius: 8px; padding: 15px; width: calc(33.333% - 20px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); transition: transform 0.2s; } .friend-card:hover { transform: translateY(-5px); } .friend-avatar { width: 60px; height: 60px; border-radius: 50%; margin-right: 15px; } .friend-info { flex-grow: 1; } .friend-name { font-size: 1.2em; font-weight: bold; margin: 0; } .friend-descr { font-size: 0.9em; color: #555; margin-top: 5px; } document.addEventListener('DOMContentLoaded', () => { const friendsListElement = document.getElementById('friends-list'); const jsonUrl = 'https://dl668.github.io/friends/friends.json'; fetch(jsonUrl) .then(response => { if (!response.ok) { throw new Error('Network response was not ok'); } return response.json(); }) .then(data => { data.forEach(friend => { const card = document.createElement('a'); card.href = friend.link; card.target = \"_blank\"; card.className = \"friend-card\"; const avatar = document.createElement('img'); avatar.src = friend.avatar; avatar.alt = `${friend.name} 的头像`; avatar.className = \"friend-avatar\"; const info = document.createElement('div'); info.className = \"friend-info\"; const name = document.createElement('p'); name.className = \"friend-name\"; name.textContent = friend.name; const descr = document.createElement('p'); descr.className = \"friend-descr\"; descr.textContent = friend.descr; info.appendChild(name); info.appendChild(descr); card.appendChild(avatar); card.appendChild(info); friendsListElement.appendChild(card); }); }) .catch(error => { console.error('There has been a problem with your fetch operation:', error); friendsListElement.innerHTML = '无法加载友链数据。'; }); });"}]